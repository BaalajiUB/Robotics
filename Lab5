import math
import sys

class node:
    def __init__(self,parent,cor):
        self.parent = parent
        self.cor = cor
        self.g = sys.maxsize
        self.h = sys.maxsize
        self.f = sys.maxsize

def validate_cell(map_grid,x,y,rows,cols): #true if invalid
    try:
        op = (map_grid[x][y]=='1' or x<0 or x>=rows or y<0 or y>=cols)
        return op
    except:
        return True

def generate_grid():
    #Reading map from text file into a matrix 20X18 #0 & 1 are strings
    map_read = open("map.txt",'r')
    lines = map_read.readlines()
    map_read.close()

    map_grid = []
    for line in lines:
        t = ''
        for i in line:
            if i.isdigit():
              t+=i
        map_grid.append(list(t))
    map_grid = map_grid[::-1]
    #for i in map_grid:
    #    print(''.join(i))
    return map_grid

def main(map_grid):
    rows = len(map_grid)
    cols = len(map_grid[0])

    start = node(None,(-8-offset_x-1,-2-offset_y-1))
    start.g = start.h = start.f = 0
    end = node(None,((args[0]//1)-offset_x-1,(args[1]//1)-offset_y-1))
    end.g = end.h = end.f = 0

    print(start.cor)
    print(end.cor)
    
    if validate_cell(map_grid,start.cor[0]//1,start.cor[1]//1,rows,cols):
        print("Invalid start point")
        return 0

    if validate_cell(map_grid,int(end.cor[0]),int(end.cor[1]),rows,cols):
        print("Invalid end point")
        return 0
    
    open_list = []
    close_list = []

    open_list.append(start)
    loop_no=0
    while(len(open_list)>0):
        #for i in open_list:
            #print(i.cor,i.f)
        print(len(open_list))
        loop_no+=1
        #find node with min f
        t = open_list[0]
        for i in open_list:
            if i.f<t.f:
                t = i
        open_list.remove(t)
        close_list.append(t)

        #if t is end node, return
        if t.cor==end.cor:
            return t
        #append all neighbors to the open_list if valid
        print("Chosen Node: ",t.cor)
        for i in neighbors:
            x = int(t.cor[0]+i[0])
            y = int(t.cor[1]+i[1])
            if validate_cell(map_grid,x,y,rows,cols)==False:
                #print(map_grid[x][y],validate_cell(map_grid,x,y,rows,cols),(x,y))
                #if in close_list: skip
                f=0
                for i in close_list:
                    if i.cor == (x,y):
                        f=1
                        break
                if f==1:
                    #print('In close_list')
                    continue
                #update if in open_list
                e_node = None
                for i in open_list:
                    if i.cor == (x,y):
                        e_node = i
                        break
                    
                if e_node==None:
                    nd = node(t,(x,y))
                    nd.g = t.g + 1
                    nd.h = math.sqrt((end.cor[0]-x)**2 + (end.cor[1]-y)**2)
                    nd.f = nd.g + nd.h
                    open_list.append(nd)
                    #print('Not in open_list', nd.f)

                else:
                    if t.g+1 < e_node.g:
                        e_node.g = t.g + 1
                        e_node.f = e_node.g + e_node.h
                        e_node.parent = t
                        #print('Updated in open_list',e_node.f)
        #if loop_no==3:
            #break
    return 1

def print_path(tail):
    for i in map_grid:
        print(''.join(i))
    path = []
    obs = []
    while(tail):
        path.append((tail.cor[0]+offset_x+1,tail.cor[1]+offset_y+1))
        map_grid[tail.cor[0]][tail.cor[1]]='X'
        tail = tail.parent
    print(path[::-1])
    for i in map_grid:
        print(''.join(i))
    
if __name__ == '__main__':
    offset_x = -10
    offset_y = -9
    args = [4.5,9.0]#input from prompt
    neighbors = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
    map_grid = generate_grid()
    tail = main(map_grid)
    if tail==1:
        print('No path available')
    elif tail!=0:
        print_path(tail)
    

    
